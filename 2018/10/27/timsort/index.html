<!DOCTYPE HTML>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  <title>CPython源码阅读——timsort | Weitang Li&#39;s blog | We&#39;ve havered enough. Let&#39;s get tae work!</title>

  
  <meta name="author" content="Weitang Li">
  

  
  <meta name="description" content="Weitang Li&#39;s blog">
  

  
  
  <meta name="keywords" content="">
  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  <meta property="og:title" content="CPython源码阅读——timsort"/>

  <meta property="og:site_name" content="Weitang Li&#39;s blog"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Weitang Li&#39;s blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?bf4c5f63e0485106a91950fc4aa87838";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>


<body>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">Weitang Li&#39;s blog</a>
    </h1>
    <p class="site-description">We&#39;ve havered enough. Let&#39;s get tae work!</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">主页</a></li>
      
        <li><a href="/archives">归档</a></li>
      
        <li><a href="/about">关于</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    <article>

  
    
    <h3 class="article-title"><span>CPython源码阅读——timsort</span></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2018/10/27/timsort/" rel="bookmark">
        <time class="entry-date published" datetime="2018-10-27T12:56:19.000Z">
          2018-10-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>对timsort的简介请见<a href="https://en.wikipedia.org/wiki/Timsort" target="_blank" rel="noopener">Wiki</a>或者<a href="https://svn.python.org/projects/python/trunk/Objects/listsort.txt" target="_blank" rel="noopener">Tim本人的小文章</a>，本文主要分析CPython的实现部分，不对原理做具体介绍。<br>版本Python3.7。代码位于<a href="https://github.com/python/cpython/blob/3.7/Objects/listobject.c" target="_blank" rel="noopener">Objects/listobject.c</a>中，大概从1000行到2000行，占据整个list实现的三分之一。本文把所有的timsort源码基本上都粘贴过来了，所以也不会短。<br>这段代码看起来其实很有意思，因为注释得比较详尽，画风稳中带皮，不失为消遣娱乐之佳品。有人说CPython这部分代码很难懂，我实在不能苟同。</p>
<a id="more"></a>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Lots of code for an adaptive, stable, natural mergesort.  There are many</span></span><br><span class="line"><span class="comment"> * pieces to this algorithm; read listsort.txt for overviews and details.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* A sortslice contains a pointer to an array of keys and a pointer to</span></span><br><span class="line"><span class="comment"> * an array of corresponding values.  In other words, keys[i]</span></span><br><span class="line"><span class="comment"> * corresponds with values[i].  If values == NULL, then the keys are</span></span><br><span class="line"><span class="comment"> * also the values.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Several convenience routines are provided here, so that keys and</span></span><br><span class="line"><span class="comment"> * values are always moved in sync.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject **keys;</span><br><span class="line">    PyObject **values;</span><br><span class="line">&#125; sortslice;</span><br></pre></td></tr></table></figure>
<p>起手式先搞了一个叫做<code>sortslice</code>的结构，后面用到的非常多。这个结构粗看起来让人摸不着头脑，好好的list哪来的成对的<code>value</code>和<code>key</code>呢？看到后面会明白这是由<a href="https://docs.python.org/3/library/stdtypes.html#list.sort" target="_blank" rel="noopener">Python排序函数的原型</a>决定的。Python的排序有个叫做<code>key</code>的关键字，允许你传入一个函数然后依据这个函数来比较list中元素的大小。在CPython内部实现上如果定义了<code>key</code>那么CPython就会首先依据<code>key</code>这个函数把list中所有元素（称作<code>value</code>）的<code>key</code>都算出来，然后再依据<code>key</code>排序，自然就出现了成对的<code>key</code>和<code>value</code>，两者在排序时要一起移动。所以这个<code>sortslice</code>是CPython特有的一个排序的基本单元，构成了一个run的基础。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Py_LOCAL_INLINE(<span class="keyword">void</span>)</span><br><span class="line">sortslice_copy(sortslice *s1, Py_ssize_t i, sortslice *s2, Py_ssize_t j)</span><br><span class="line">&#123;</span><br><span class="line">    s1-&gt;keys[i] = s2-&gt;keys[j];</span><br><span class="line">    <span class="keyword">if</span> (s1-&gt;values != <span class="literal">NULL</span>)</span><br><span class="line">        s1-&gt;values[i] = s2-&gt;values[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Py_LOCAL_INLINE(<span class="keyword">void</span>)</span><br><span class="line">sortslice_copy_incr(sortslice *dst, sortslice *src)</span><br><span class="line">&#123;</span><br><span class="line">    *dst-&gt;keys++ = *src-&gt;keys++;</span><br><span class="line">    <span class="keyword">if</span> (dst-&gt;values != <span class="literal">NULL</span>)</span><br><span class="line">        *dst-&gt;values++ = *src-&gt;values++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Py_LOCAL_INLINE(<span class="keyword">void</span>)</span><br><span class="line">sortslice_copy_decr(sortslice *dst, sortslice *src)</span><br><span class="line">&#123;</span><br><span class="line">    *dst-&gt;keys-- = *src-&gt;keys--;</span><br><span class="line">    <span class="keyword">if</span> (dst-&gt;values != <span class="literal">NULL</span>)</span><br><span class="line">        *dst-&gt;values-- = *src-&gt;values--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Py_LOCAL_INLINE(<span class="keyword">void</span>)</span><br><span class="line">sortslice_memcpy(sortslice *s1, Py_ssize_t i, sortslice *s2, Py_ssize_t j,</span><br><span class="line">                 Py_ssize_t n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;s1-&gt;keys[i], &amp;s2-&gt;keys[j], <span class="keyword">sizeof</span>(PyObject *) * n);</span><br><span class="line">    <span class="keyword">if</span> (s1-&gt;values != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;s1-&gt;values[i], &amp;s2-&gt;values[j], <span class="keyword">sizeof</span>(PyObject *) * n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Py_LOCAL_INLINE(<span class="keyword">void</span>)</span><br><span class="line">sortslice_memmove(sortslice *s1, Py_ssize_t i, sortslice *s2, Py_ssize_t j,</span><br><span class="line">                  Py_ssize_t n)</span><br><span class="line">&#123;</span><br><span class="line">    memmove(&amp;s1-&gt;keys[i], &amp;s2-&gt;keys[j], <span class="keyword">sizeof</span>(PyObject *) * n);</span><br><span class="line">    <span class="keyword">if</span> (s1-&gt;values != <span class="literal">NULL</span>)</span><br><span class="line">        memmove(&amp;s1-&gt;values[i], &amp;s2-&gt;values[j], <span class="keyword">sizeof</span>(PyObject *) * n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Py_LOCAL_INLINE(<span class="keyword">void</span>)</span><br><span class="line">sortslice_advance(sortslice *slice, Py_ssize_t n)</span><br><span class="line">&#123;</span><br><span class="line">    slice-&gt;keys += n;</span><br><span class="line">    <span class="keyword">if</span> (slice-&gt;values != <span class="literal">NULL</span>)</span><br><span class="line">        slice-&gt;values += n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>随后定义了一大串用来操作<code>sortslice</code>的内联函数，基本上类似于一个“类”了。这些函数简单来说就是优先处理<code>key</code>，然后如果有<code>value</code>再对<code>value</code>做一样的操作。<code>Py_LOCAL_INLINE</code>的定义依平台而定，目标是实现最快速的局域函数调用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Comparison function: ms-&gt;key_compare, which is set at run-time in</span></span><br><span class="line"><span class="comment"> * listsort_impl to optimize for various special cases.</span></span><br><span class="line"><span class="comment"> * Returns -1 on error, 1 if x &lt; y, 0 if x &gt;= y.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISLT(X, Y) (*(ms-&gt;key_compare))(X, Y, ms)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Compare X to Y via "&lt;".  Goto "fail" if the comparison raises an</span></span><br><span class="line"><span class="comment">   error.  Else "k" is set to true iff X&lt;Y, and an "if (k)" block is</span></span><br><span class="line"><span class="comment">   started.  It makes more sense in context &lt;wink&gt;.  X and Y are PyObject*s.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IFLT(X, Y) <span class="meta-keyword">if</span> ((k = ISLT(X, Y)) &lt; 0) goto fail;  \</span></span><br><span class="line">           <span class="keyword">if</span> (k)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The maximum number of entries in a MergeState's pending-runs stack.</span></span><br><span class="line"><span class="comment"> * This is enough to sort arrays of size up to about</span></span><br><span class="line"><span class="comment"> *     32 * phi ** MAX_MERGE_PENDING</span></span><br><span class="line"><span class="comment"> * where phi ~= 1.618.  85 is ridiculouslylarge enough, good for an array</span></span><br><span class="line"><span class="comment"> * with 2**64 elements.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_MERGE_PENDING 85</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* When we get into galloping mode, we stay there until both runs win less</span></span><br><span class="line"><span class="comment"> * often than MIN_GALLOP consecutive times.  See listsort.txt for more info.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_GALLOP 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Avoid malloc for small temp arrays. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MERGESTATE_TEMP_SIZE 256</span></span><br></pre></td></tr></table></figure></p>
<p>再然后定义了一些宏。比较大小的宏让人心痛：CPython里要比较元素大小的overhead还是相当大的。<code>MAX_MERGE_PENDING</code>和<code>MIN_GALLOP</code>的注释都做的非常清楚，把数值的选择交代明白了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* One MergeState exists on the stack per invocation of mergesort.  It's just</span></span><br><span class="line"><span class="comment"> * a convenient way to pass state around among the helper functions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_slice</span> &#123;</span></span><br><span class="line">    sortslice base;</span><br><span class="line">    Py_ssize_t len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_MergeState</span> <span class="title">MergeState</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_MergeState</span> &#123;</span></span><br><span class="line">    <span class="comment">/* This controls when we get *into* galloping mode.  It's initialized</span></span><br><span class="line"><span class="comment">     * to MIN_GALLOP.  merge_lo and merge_hi tend to nudge it higher for</span></span><br><span class="line"><span class="comment">     * random data, and lower for highly structured data.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Py_ssize_t min_gallop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 'a' is temp storage to help with merges.  It contains room for</span></span><br><span class="line"><span class="comment">     * alloced entries.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sortslice a;        <span class="comment">/* may point to temparray below */</span></span><br><span class="line">    Py_ssize_t alloced;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* A stack of n pending runs yet to be merged.  Run #i starts at</span></span><br><span class="line"><span class="comment">     * address base[i] and extends for len[i] elements.  It's always</span></span><br><span class="line"><span class="comment">     * true (so long as the indices are in bounds) that</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     pending[i].base + pending[i].len == pending[i+1].base</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * so we could cut the storage for this, but it's a minor amount,</span></span><br><span class="line"><span class="comment">     * and keeping all the info explicit simplifies the code.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s_slice</span> <span class="title">pending</span>[<span class="title">MAX_MERGE_PENDING</span>];</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 'a' points to this when possible, rather than muck with malloc. */</span></span><br><span class="line">    PyObject *temparray[MERGESTATE_TEMP_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This is the function we will use to compare two keys,</span></span><br><span class="line"><span class="comment">     * even when none of our special cases apply and we have to use</span></span><br><span class="line"><span class="comment">     * safe_object_compare. */</span></span><br><span class="line">    <span class="keyword">int</span> (*key_compare)(PyObject *, PyObject *, MergeState *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This function is used by unsafe_object_compare to optimize comparisons</span></span><br><span class="line"><span class="comment">     * when we know our list is type-homogeneous but we can't assume anything else.</span></span><br><span class="line"><span class="comment">     * In the pre-sort check it is set equal to key-&gt;ob_type-&gt;tp_richcompare */</span></span><br><span class="line">    PyObject *(*key_richcompare)(PyObject *, PyObject *, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This function is used by unsafe_tuple_compare to compare the first elements</span></span><br><span class="line"><span class="comment">     * of tuples. It may be set to safe_object_compare, but the idea is that hopefully</span></span><br><span class="line"><span class="comment">     * we can assume more, and use one of the special-case compares. */</span></span><br><span class="line">    <span class="keyword">int</span> (*tuple_elem_compare)(PyObject *, PyObject *, MergeState *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下面首先利用<code>s_slice</code>对<code>sortslice</code>进行了进一步包装，添加了长度字段，形成了一个完整的run的结构。然后定义了一个<code>MergeState</code>，用于包装进行timsort时的众多metadata，在传参时比较方便。里面有一些对timsort具有明显关键作用的参数如<code>min_gallop</code>、保存run的栈<code>pending</code>、进行merge时的临时空间<code>temparray</code>以及与之相关的指针等，也有一些为Python的泛型特点准备的函数指针。</p>
<h2 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h2><p>很多基于比较的排序或多或少都依赖强大的插入排序对小的数据片段进行处理，timsort也不例外，而且使用得相当巧妙。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* binarysort is the best method for sorting small arrays: it does</span></span><br><span class="line"><span class="comment">   few compares, but can do data movement quadratic in the number of</span></span><br><span class="line"><span class="comment">   elements.</span></span><br><span class="line"><span class="comment">   [lo, hi) is a contiguous slice of a list, and is sorted via</span></span><br><span class="line"><span class="comment">   binary insertion.  This sort is stable.</span></span><br><span class="line"><span class="comment">   On entry, must have lo &lt;= start &lt;= hi, and that [lo, start) is already</span></span><br><span class="line"><span class="comment">   sorted (pass start == lo if you don't know!).</span></span><br><span class="line"><span class="comment">   If islt() complains return -1, else 0.</span></span><br><span class="line"><span class="comment">   Even in case of error, the output slice will be some permutation of</span></span><br><span class="line"><span class="comment">   the input (nothing is lost or duplicated).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">binarysort(MergeState *ms, sortslice lo, PyObject **hi, PyObject **start)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t k;</span><br><span class="line">    PyObject **l, **p, **r;</span><br><span class="line">    PyObject *pivot;</span><br><span class="line"></span><br><span class="line">    assert(lo.keys &lt;= start &amp;&amp; start &lt;= hi);</span><br><span class="line">    <span class="comment">/* assert [lo, start) is sorted */</span></span><br><span class="line">    <span class="keyword">if</span> (lo.keys == start)</span><br><span class="line">        ++start;</span><br><span class="line">    <span class="keyword">for</span> (; start &lt; hi; ++start) &#123;</span><br><span class="line">        <span class="comment">/* set l to where *start belongs */</span></span><br><span class="line">        l = lo.keys;</span><br><span class="line">        r = start;</span><br><span class="line">        pivot = *r;</span><br><span class="line">        <span class="comment">/* Invariants:</span></span><br><span class="line"><span class="comment">         * pivot &gt;= all in [lo, l).</span></span><br><span class="line"><span class="comment">         * pivot  &lt; all in [r, start).</span></span><br><span class="line"><span class="comment">         * The second is vacuously true at the start.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        assert(l &lt; r);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            p = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            IFLT(pivot, *p)</span><br><span class="line">                r = p;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = p+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (l &lt; r);</span><br><span class="line">        assert(l == r);</span><br><span class="line">        <span class="comment">/* The invariants still hold, so pivot &gt;= all in [lo, l) and</span></span><br><span class="line"><span class="comment">           pivot &lt; all in [l, start), so pivot belongs at l.  Note</span></span><br><span class="line"><span class="comment">           that if there are elements equal to pivot, l points to the</span></span><br><span class="line"><span class="comment">           first slot after them -- that's why this sort is stable.</span></span><br><span class="line"><span class="comment">           Slide over to make room.</span></span><br><span class="line"><span class="comment">           Caution: using memmove is much slower under MSVC 5;</span></span><br><span class="line"><span class="comment">           we're not usually moving many slots. */</span></span><br><span class="line">        <span class="keyword">for</span> (p = start; p &gt; l; --p)</span><br><span class="line">            *p = *(p<span class="number">-1</span>);</span><br><span class="line">        *l = pivot;</span><br><span class="line">        <span class="keyword">if</span> (lo.values != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_ssize_t offset = lo.values - lo.keys;</span><br><span class="line">            p = start + offset;</span><br><span class="line">            pivot = *p;</span><br><span class="line">            l += offset;</span><br><span class="line">            <span class="keyword">for</span> (p = start + offset; p &gt; l; --p)</span><br><span class="line">                *p = *(p<span class="number">-1</span>);</span><br><span class="line">            *l = pivot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> fail:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>timsort中的二分插入排序和一般的二分插入排序不一样的地方在于额外多了一些参数，特别是<code>start</code>。我们来看一下这个排序函数的参数都是什么含义。</p>
<ol>
<li><code>ms</code>包含了非常多的信息，粗看起来好像在当前函数中没有用到，其实为大小比较提供了进行比较的函数。</li>
<li><code>lo</code>里面是两个指针，指向当前待排序的<code>key</code>和<code>value</code>的地址。</li>
<li><code>hi</code>是单个指针，指向待排序的<code>key</code>的结束地址。</li>
<li><code>start</code>指向开始排序的元素的地址。这是timsort中二分插入排序和其它二分插入排序的最大区别。一般的排序时不需要这个指针的，直接从头开始排就行了。Timsort需要这个指针的原因是timsort需要把长度不够一个run的单调序列强行拉成一个run长。这样形成的run前半部分是有序的，后半部分是无序的，那么要把这个run变成有序的就可以把不单调的部分就和前面单调的部分一起放到这个二分插入排序里来进行排序，这时我们知道<code>start</code>之前已经是单调的了，因此从<code>start</code>开始排序即可。通过这个二分插入排序函数我们不难想象在数据比较随机的时候timsort可以很自然地退化为mergesort。</li>
</ol>
<p>除此之外，在这个二分插入排序最后，我们看到了在排序完毕后将<code>value</code>的值也进行位移、插入的过程。为什么不在对<code>key</code>排序的时候顺便就把在一个结构里的<code>value</code>的一起做了呢？因为数据局部性啊。</p>
<h2 id="山雨欲来风满楼"><a href="#山雨欲来风满楼" class="headerlink" title="山雨欲来风满楼"></a>山雨欲来风满楼</h2><p>下面就要进入timsort最精华最出彩的部分了。首先登场的是<code>count_run</code>函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Return the length of the run beginning at lo, in the slice [lo, hi).  lo &lt; hi</span><br><span class="line">is required on entry.  &quot;A run&quot; is the longest ascending sequence, with</span><br><span class="line"></span><br><span class="line">    lo[0] &lt;= lo[1] &lt;= lo[2] &lt;= ...</span><br><span class="line"></span><br><span class="line">or the longest descending sequence, with</span><br><span class="line"></span><br><span class="line">    lo[0] &gt; lo[1] &gt; lo[2] &gt; ...</span><br><span class="line"></span><br><span class="line">Boolean *descending is set to 0 in the former case, or to 1 in the latter.</span><br><span class="line">For its intended use in a stable mergesort, the strictness of the defn of</span><br><span class="line">&quot;descending&quot; is needed so that the caller can safely reverse a descending</span><br><span class="line">sequence without violating stability (strict &gt; ensures there are no equal</span><br><span class="line">elements to get out of order).</span><br><span class="line"></span><br><span class="line">Returns -1 in case of error.</span><br><span class="line">*/</span><br><span class="line">static Py_ssize_t</span><br><span class="line">count_run(MergeState *ms, PyObject **lo, PyObject **hi, int *descending)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t k;</span><br><span class="line">    Py_ssize_t n;</span><br><span class="line"></span><br><span class="line">    assert(lo &lt; hi);</span><br><span class="line">    *descending = 0;</span><br><span class="line">    ++lo;</span><br><span class="line">    if (lo == hi)</span><br><span class="line">        return 1;</span><br><span class="line"></span><br><span class="line">    n = 2;</span><br><span class="line">    IFLT(*lo, *(lo-1)) &#123;</span><br><span class="line">        *descending = 1;</span><br><span class="line">        for (lo = lo+1; lo &lt; hi; ++lo, ++n) &#123;</span><br><span class="line">            IFLT(*lo, *(lo-1))</span><br><span class="line">                ;</span><br><span class="line">            else</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        for (lo = lo+1; lo &lt; hi; ++lo, ++n) &#123;</span><br><span class="line">            IFLT(*lo, *(lo-1))</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return n;</span><br><span class="line">fail:</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数从<code>lo</code>规定的地方开始，到<code>hi</code>规定的地方结束，寻找一个单调的序列作为run的前体（长度不够再来凑）。注意这里如果是单调增不要求严格单调，但是单调减要求是严格的。timsort会反转单调减的序列把它变成单调增，一方面我们希望这个反转处理的元素越少越好，另一方面我们也不希望单调减序列中有相同元素使反转操作导致排序不稳定。因此这里的单调/严格单调要求不是随意选择的。</p>
<h2 id="Gallop"><a href="#Gallop" class="headerlink" title="Gallop!"></a>Gallop!</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Locate the proper position of key in a sorted vector; if the vector contains</span></span><br><span class="line"><span class="comment">an element equal to key, return the position immediately to the left of</span></span><br><span class="line"><span class="comment">the leftmost equal element.  [gallop_right() does the same except returns</span></span><br><span class="line"><span class="comment">the position to the right of the rightmost equal element (if any).]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">"a" is a sorted vector with n elements, starting at a[0].  n must be &gt; 0.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">"hint" is an index at which to begin the search, 0 &lt;= hint &lt; n.  The closer</span></span><br><span class="line"><span class="comment">hint is to the final result, the faster this runs.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The return value is the int k in 0..n such that</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    a[k-1] &lt; key &lt;= a[k]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">pretending that *(a-1) is minus infinity and a[n] is plus infinity.  IOW,</span></span><br><span class="line"><span class="comment">key belongs at index k; or, IOW, the first k elements of a should precede</span></span><br><span class="line"><span class="comment">key, and the last n-k should follow key.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Returns -1 on error.  See listsort.txt for info on the method.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> Py_ssize_t</span><br><span class="line">gallop_left(MergeState *ms, PyObject *key, PyObject **a, Py_ssize_t n, Py_ssize_t hint)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t ofs;</span><br><span class="line">    Py_ssize_t lastofs;</span><br><span class="line">    Py_ssize_t k;</span><br><span class="line"></span><br><span class="line">    assert(key &amp;&amp; a &amp;&amp; n &gt; <span class="number">0</span> &amp;&amp; hint &gt;= <span class="number">0</span> &amp;&amp; hint &lt; n);</span><br><span class="line"></span><br><span class="line">    a += hint;</span><br><span class="line">    lastofs = <span class="number">0</span>;</span><br><span class="line">    ofs = <span class="number">1</span>;</span><br><span class="line">    IFLT(*a, key) &#123;</span><br><span class="line">        <span class="comment">/* a[hint] &lt; key -- gallop right, until</span></span><br><span class="line"><span class="comment">         * a[hint + lastofs] &lt; key &lt;= a[hint + ofs]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">const</span> Py_ssize_t maxofs = n - hint;             <span class="comment">/* &amp;a[n-1] is highest */</span></span><br><span class="line">        <span class="keyword">while</span> (ofs &lt; maxofs) &#123;</span><br><span class="line">            IFLT(a[ofs], key) &#123;</span><br><span class="line">                lastofs = ofs;</span><br><span class="line">                ofs = (ofs &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (ofs &lt;= <span class="number">0</span>)                   <span class="comment">/* int overflow */</span></span><br><span class="line">                    ofs = maxofs;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                <span class="comment">/* key &lt;= a[hint + ofs] */</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ofs &gt; maxofs)</span><br><span class="line">            ofs = maxofs;</span><br><span class="line">        <span class="comment">/* Translate back to offsets relative to &amp;a[0]. */</span></span><br><span class="line">        lastofs += hint;</span><br><span class="line">        ofs += hint;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* key &lt;= a[hint] -- gallop left, until</span></span><br><span class="line"><span class="comment">         * a[hint - ofs] &lt; key &lt;= a[hint - lastofs]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">const</span> Py_ssize_t maxofs = hint + <span class="number">1</span>;             <span class="comment">/* &amp;a[0] is lowest */</span></span><br><span class="line">        <span class="keyword">while</span> (ofs &lt; maxofs) &#123;</span><br><span class="line">            IFLT(*(a-ofs), key)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">/* key &lt;= a[hint - ofs] */</span></span><br><span class="line">            lastofs = ofs;</span><br><span class="line">            ofs = (ofs &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (ofs &lt;= <span class="number">0</span>)               <span class="comment">/* int overflow */</span></span><br><span class="line">                ofs = maxofs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ofs &gt; maxofs)</span><br><span class="line">            ofs = maxofs;</span><br><span class="line">        <span class="comment">/* Translate back to positive offsets relative to &amp;a[0]. */</span></span><br><span class="line">        k = lastofs;</span><br><span class="line">        lastofs = hint - ofs;</span><br><span class="line">        ofs = hint - k;</span><br><span class="line">    &#125;</span><br><span class="line">    a -= hint;</span><br><span class="line"></span><br><span class="line">    assert(<span class="number">-1</span> &lt;= lastofs &amp;&amp; lastofs &lt; ofs &amp;&amp; ofs &lt;= n);</span><br><span class="line">    <span class="comment">/* Now a[lastofs] &lt; key &lt;= a[ofs], so key belongs somewhere to the</span></span><br><span class="line"><span class="comment">     * right of lastofs but no farther right than ofs.  Do a binary</span></span><br><span class="line"><span class="comment">     * search, with invariant a[lastofs-1] &lt; key &lt;= a[ofs].</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ++lastofs;</span><br><span class="line">    <span class="keyword">while</span> (lastofs &lt; ofs) &#123;</span><br><span class="line">        Py_ssize_t m = lastofs + ((ofs - lastofs) &gt;&gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        IFLT(a[m], key)</span><br><span class="line">            lastofs = m+<span class="number">1</span>;              <span class="comment">/* a[m] &lt; key */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ofs = m;                    <span class="comment">/* key &lt;= a[m] */</span></span><br><span class="line">    &#125;</span><br><span class="line">    assert(lastofs == ofs);             <span class="comment">/* so a[ofs-1] &lt; key &lt;= a[ofs] */</span></span><br><span class="line">    <span class="keyword">return</span> ofs;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是威名远扬的gallop函数，本质是对待查找元素常常位于有序数组某一端这种情况进行优化的二分查找。几个参数都比较显然，<code>hint</code>看起来很fancy但在实际当中并没有得到有效应用，其值往往都是端点位置。这个函数主要分为两个大块，第一块是一段if-else，通过gallop找到<code>key</code>大概在的区间，然后第二块通过二分查找确定<code>key</code>的位置。if-else段两个逻辑也很类似，只不过一个是往右gallop一个是往左gallop。这段代码首先要夸作者注释做的好，不多但是把最最关键的都点得清清楚楚，读起来好似按摩神经。然后还要夸对于int overflow的细节的处理，这让我一个基本上只写Python的肃然起敬。这里贴上来的代码是<code>gallop_left</code>，那么同理还有<code>gallop_right</code>，不同之处在于有多个与<code>key</code>相同的元素时的处理，与算法的稳定性有关。<br>下面就要做<code>merge</code>了。</p>
<h2 id="Merge的基础设施"><a href="#Merge的基础设施" class="headerlink" title="Merge的基础设施"></a>Merge的基础设施</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Conceptually a MergeState's constructor. */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">merge_init(MergeState *ms, Py_ssize_t list_size, <span class="keyword">int</span> has_keyfunc)</span><br><span class="line">&#123;</span><br><span class="line">    assert(ms != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (has_keyfunc) &#123;</span><br><span class="line">        <span class="comment">/* The temporary space for merging will need at most half the list</span></span><br><span class="line"><span class="comment">         * size rounded up.  Use the minimum possible space so we can use the</span></span><br><span class="line"><span class="comment">         * rest of temparray for other things.  In particular, if there is</span></span><br><span class="line"><span class="comment">         * enough extra space, listsort() will use it to store the keys.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ms-&gt;alloced = (list_size + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* ms-&gt;alloced describes how many keys will be stored at</span></span><br><span class="line"><span class="comment">           ms-&gt;temparray, but we also need to store the values.  Hence,</span></span><br><span class="line"><span class="comment">           ms-&gt;alloced is capped at half of MERGESTATE_TEMP_SIZE. */</span></span><br><span class="line">        <span class="keyword">if</span> (MERGESTATE_TEMP_SIZE / <span class="number">2</span> &lt; ms-&gt;alloced)</span><br><span class="line">            ms-&gt;alloced = MERGESTATE_TEMP_SIZE / <span class="number">2</span>;</span><br><span class="line">        ms-&gt;a.values = &amp;ms-&gt;temparray[ms-&gt;alloced];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ms-&gt;alloced = MERGESTATE_TEMP_SIZE;</span><br><span class="line">        ms-&gt;a.values = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ms-&gt;a.keys = ms-&gt;temparray;</span><br><span class="line">    ms-&gt;n = <span class="number">0</span>;</span><br><span class="line">    ms-&gt;min_gallop = MIN_GALLOP;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free all the temp memory owned by the MergeState.  This must be called</span></span><br><span class="line"><span class="comment"> * when you're done with a MergeState, and may be called before then if</span></span><br><span class="line"><span class="comment"> * you want to free the temp memory early.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">merge_freemem(MergeState *ms)</span><br><span class="line">&#123;</span><br><span class="line">    assert(ms != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ms-&gt;a.keys != ms-&gt;temparray)</span><br><span class="line">        PyMem_Free(ms-&gt;a.keys);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Ensure enough temp memory for 'need' array slots is available.</span></span><br><span class="line"><span class="comment"> * Returns 0 on success and -1 if the memory can't be gotten.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">merge_getmem(MergeState *ms, Py_ssize_t need)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> multiplier;</span><br><span class="line"></span><br><span class="line">    assert(ms != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (need &lt;= ms-&gt;alloced)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    multiplier = ms-&gt;a.values != <span class="literal">NULL</span> ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't realloc!  That can cost cycles to copy the old data, but</span></span><br><span class="line"><span class="comment">     * we don't care what's in the block.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    merge_freemem(ms);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">size_t</span>)need &gt; PY_SSIZE_T_MAX / <span class="keyword">sizeof</span>(PyObject *) / multiplier) &#123;</span><br><span class="line">        PyErr_NoMemory();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ms-&gt;a.keys = (PyObject **)PyMem_Malloc(multiplier * need</span><br><span class="line">                                          * <span class="keyword">sizeof</span>(PyObject *));</span><br><span class="line">    <span class="keyword">if</span> (ms-&gt;a.keys != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ms-&gt;alloced = need;</span><br><span class="line">        <span class="keyword">if</span> (ms-&gt;a.values != <span class="literal">NULL</span>)</span><br><span class="line">            ms-&gt;a.values = &amp;ms-&gt;a.keys[need];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PyErr_NoMemory();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MERGE_GETMEM(MS, NEED) ((NEED) <span class="meta-string">&lt;= (MS)-&gt;alloced ? 0 :   \</span></span></span><br><span class="line">                                merge_getmem(MS, NEED))</span><br></pre></td></tr></table></figure>
<p>首先是一个类似<code>MergeState</code>构造函数的函数，不难发现这个函数并不是严格的构造函数，有许多变量都没处理，调用的时候其实也只被调用了一次，所以个人感觉这个函数意义并不是很大。之后是对<code>MergeState</code>维护的临时空间内存进行管理的函数。在<code>merge_getmem</code>里有一个貌似很奇怪的<code>multiplier</code>，这是由于当同时存在<code>key</code>和<code>value</code>时，所需要的空间两倍于只有<code>key</code>时的空间。最后定义的<code>MERGE_GETMEM</code>看起来和<code>merge_getmem</code>中实现的功能完全重叠，不知为何，等CPython开启issue以后一定要问一下。</p>
<h2 id="merge-阴阳太极"><a href="#merge-阴阳太极" class="headerlink" title="merge-阴阳太极"></a>merge-阴阳太极</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">/* Merge the na elements starting at ssa with the nb elements starting at</span><br><span class="line"> * ssb.keys = ssa.keys + na in a stable way, in-place.  na and nb must be &gt; 0.</span><br><span class="line"> * Must also have that ssa.keys[na-1] belongs at the end of the merge, and</span><br><span class="line"> * should have na &lt;= nb.  See listsort.txt for more info.  Return 0 if</span><br><span class="line"> * successful, -1 if error.</span><br><span class="line"> */</span><br><span class="line">static Py_ssize_t</span><br><span class="line">merge_lo(MergeState *ms, sortslice ssa, Py_ssize_t na,</span><br><span class="line">         sortslice ssb, Py_ssize_t nb)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t k;</span><br><span class="line">    sortslice dest;</span><br><span class="line">    int result = -1;            /* guilty until proved innocent */</span><br><span class="line">    Py_ssize_t min_gallop;</span><br><span class="line"></span><br><span class="line">    assert(ms &amp;&amp; ssa.keys &amp;&amp; ssb.keys &amp;&amp; na &gt; 0 &amp;&amp; nb &gt; 0);</span><br><span class="line">    assert(ssa.keys + na == ssb.keys);</span><br><span class="line">    if (MERGE_GETMEM(ms, na) &lt; 0)</span><br><span class="line">        return -1;</span><br><span class="line">    sortslice_memcpy(&amp;ms-&gt;a, 0, &amp;ssa, 0, na);</span><br><span class="line">    dest = ssa;</span><br><span class="line">    ssa = ms-&gt;a;</span><br><span class="line"></span><br><span class="line">    sortslice_copy_incr(&amp;dest, &amp;ssb);</span><br><span class="line">    --nb;</span><br><span class="line">    if (nb == 0)</span><br><span class="line">        goto Succeed;</span><br><span class="line">    if (na == 1)</span><br><span class="line">        goto CopyB;</span><br><span class="line"></span><br><span class="line">    min_gallop = ms-&gt;min_gallop;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        Py_ssize_t acount = 0;          /* # of times A won in a row */</span><br><span class="line">        Py_ssize_t bcount = 0;          /* # of times B won in a row */</span><br><span class="line"></span><br><span class="line">        /* Do the straightforward thing until (if ever) one run</span><br><span class="line">         * appears to win consistently.</span><br><span class="line">         */</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            assert(na &gt; 1 &amp;&amp; nb &gt; 0);</span><br><span class="line">            k = ISLT(ssb.keys[0], ssa.keys[0]);</span><br><span class="line">            if (k) &#123;</span><br><span class="line">                if (k &lt; 0)</span><br><span class="line">                    goto Fail;</span><br><span class="line">                sortslice_copy_incr(&amp;dest, &amp;ssb);</span><br><span class="line">                ++bcount;</span><br><span class="line">                acount = 0;</span><br><span class="line">                --nb;</span><br><span class="line">                if (nb == 0)</span><br><span class="line">                    goto Succeed;</span><br><span class="line">                if (bcount &gt;= min_gallop)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#123;</span><br><span class="line">                sortslice_copy_incr(&amp;dest, &amp;ssa);</span><br><span class="line">                ++acount;</span><br><span class="line">                bcount = 0;</span><br><span class="line">                --na;</span><br><span class="line">                if (na == 1)</span><br><span class="line">                    goto CopyB;</span><br><span class="line">                if (acount &gt;= min_gallop)</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* One run is winning so consistently that galloping may</span><br><span class="line">         * be a huge win.  So try that, and continue galloping until</span><br><span class="line">         * (if ever) neither run appears to be winning consistently</span><br><span class="line">         * anymore.</span><br><span class="line">         */</span><br><span class="line">        ++min_gallop;</span><br><span class="line">        do &#123;</span><br><span class="line">            assert(na &gt; 1 &amp;&amp; nb &gt; 0);</span><br><span class="line">            min_gallop -= min_gallop &gt; 1;</span><br><span class="line">            ms-&gt;min_gallop = min_gallop;</span><br><span class="line">            k = gallop_right(ms, ssb.keys[0], ssa.keys, na, 0);</span><br><span class="line">            acount = k;</span><br><span class="line">            if (k) &#123;</span><br><span class="line">                if (k &lt; 0)</span><br><span class="line">                    goto Fail;</span><br><span class="line">                sortslice_memcpy(&amp;dest, 0, &amp;ssa, 0, k);</span><br><span class="line">                sortslice_advance(&amp;dest, k);</span><br><span class="line">                sortslice_advance(&amp;ssa, k);</span><br><span class="line">                na -= k;</span><br><span class="line">                if (na == 1)</span><br><span class="line">                    goto CopyB;</span><br><span class="line">                /* na==0 is impossible now if the comparison</span><br><span class="line">                 * function is consistent, but we can&apos;t assume</span><br><span class="line">                 * that it is.</span><br><span class="line">                 */</span><br><span class="line">                if (na == 0)</span><br><span class="line">                    goto Succeed;</span><br><span class="line">            &#125;</span><br><span class="line">            sortslice_copy_incr(&amp;dest, &amp;ssb);</span><br><span class="line">            --nb;</span><br><span class="line">            if (nb == 0)</span><br><span class="line">                goto Succeed;</span><br><span class="line"></span><br><span class="line">            k = gallop_left(ms, ssa.keys[0], ssb.keys, nb, 0);</span><br><span class="line">            bcount = k;</span><br><span class="line">            if (k) &#123;</span><br><span class="line">                if (k &lt; 0)</span><br><span class="line">                    goto Fail;</span><br><span class="line">                sortslice_memmove(&amp;dest, 0, &amp;ssb, 0, k);</span><br><span class="line">                sortslice_advance(&amp;dest, k);</span><br><span class="line">                sortslice_advance(&amp;ssb, k);</span><br><span class="line">                nb -= k;</span><br><span class="line">                if (nb == 0)</span><br><span class="line">                    goto Succeed;</span><br><span class="line">            &#125;</span><br><span class="line">            sortslice_copy_incr(&amp;dest, &amp;ssa);</span><br><span class="line">            --na;</span><br><span class="line">            if (na == 1)</span><br><span class="line">                goto CopyB;</span><br><span class="line">        &#125; while (acount &gt;= MIN_GALLOP || bcount &gt;= MIN_GALLOP);</span><br><span class="line">        ++min_gallop;           /* penalize it for leaving galloping mode */</span><br><span class="line">        ms-&gt;min_gallop = min_gallop;</span><br><span class="line">    &#125;</span><br><span class="line">Succeed:</span><br><span class="line">    result = 0;</span><br><span class="line">Fail:</span><br><span class="line">    if (na)</span><br><span class="line">        sortslice_memcpy(&amp;dest, 0, &amp;ssa, 0, na);</span><br><span class="line">    return result;</span><br><span class="line">CopyB:</span><br><span class="line">    assert(na == 1 &amp;&amp; nb &gt; 0);</span><br><span class="line">    /* The last element of ssa belongs at the end of the merge. */</span><br><span class="line">    sortslice_memmove(&amp;dest, 0, &amp;ssb, 0, nb);</span><br><span class="line">    sortslice_copy(&amp;dest, nb, &amp;ssa, 0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后就是一个具体进行merge的函数了，由于需要在gallop mode和正常mode里面跳来跳去，代码相对复杂，不过从这里我们看到了C中<code>goto</code>的巧妙应用。这个函数一开始的预处理主要是把较小的run拷贝到临时空间里去，最后的后处理也是想尽量利用<code>memmove</code>或者<code>memcpy</code>快速处理merge的尾巴。主要部分包含两个嵌套的循环，外层循环没有跳出条件，只能靠<code>goto</code>强行改变指令地址。如果使用其它语言想把这个功能写好恐怕不太容易，少不了一些奇奇怪怪的flag。内层循环有两个，第一个进行正常的merge，同时悄悄在小本本上记一些东西，最后要么成功要么切换模式；第二个进行gallop。gallop中好像进行了两次gallop，实际相当于是一个if-else，分别对应于不同数组上的gallop。依靠外层循环，算法得以在两种模式间不断切换。两个模式中间有个<code>++min_gallop</code>让人困惑——从正常模式切换到gallop难道不应该减小<code>min_gallop</code>吗？其实这里要加的原因是后面一进入gallop循环就要大力减。除了<code>merge_lo</code>自然也有<code>merge_hi</code>，代码类似不再赘述。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Merge the two runs at stack indices i and i+1.</span></span><br><span class="line"><span class="comment"> * Returns 0 on success, -1 on error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> Py_ssize_t</span><br><span class="line">merge_at(MergeState *ms, Py_ssize_t i)</span><br><span class="line">&#123;</span><br><span class="line">    sortslice ssa, ssb;</span><br><span class="line">    Py_ssize_t na, nb;</span><br><span class="line">    Py_ssize_t k;</span><br><span class="line"></span><br><span class="line">    assert(ms != <span class="literal">NULL</span>);</span><br><span class="line">    assert(ms-&gt;n &gt;= <span class="number">2</span>);</span><br><span class="line">    assert(i &gt;= <span class="number">0</span>);</span><br><span class="line">    assert(i == ms-&gt;n - <span class="number">2</span> || i == ms-&gt;n - <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    ssa = ms-&gt;pending[i].base;</span><br><span class="line">    na = ms-&gt;pending[i].len;</span><br><span class="line">    ssb = ms-&gt;pending[i+<span class="number">1</span>].base;</span><br><span class="line">    nb = ms-&gt;pending[i+<span class="number">1</span>].len;</span><br><span class="line">    assert(na &gt; <span class="number">0</span> &amp;&amp; nb &gt; <span class="number">0</span>);</span><br><span class="line">    assert(ssa.keys + na == ssb.keys);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Record the length of the combined runs; if i is the 3rd-last</span></span><br><span class="line"><span class="comment">     * run now, also slide over the last run (which isn't involved</span></span><br><span class="line"><span class="comment">     * in this merge).  The current run i+1 goes away in any case.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ms-&gt;pending[i].len = na + nb;</span><br><span class="line">    <span class="keyword">if</span> (i == ms-&gt;n - <span class="number">3</span>)</span><br><span class="line">        ms-&gt;pending[i+<span class="number">1</span>] = ms-&gt;pending[i+<span class="number">2</span>];</span><br><span class="line">    --ms-&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Where does b start in a?  Elements in a before that can be</span></span><br><span class="line"><span class="comment">     * ignored (already in place).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    k = gallop_right(ms, *ssb.keys, ssa.keys, na, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    sortslice_advance(&amp;ssa, k);</span><br><span class="line">    na -= k;</span><br><span class="line">    <span class="keyword">if</span> (na == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Where does a end in b?  Elements in b after that can be</span></span><br><span class="line"><span class="comment">     * ignored (already in place).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    nb = gallop_left(ms, ssa.keys[na<span class="number">-1</span>], ssb.keys, nb, nb<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (nb &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> nb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Merge what remains of the runs, using a temp array with</span></span><br><span class="line"><span class="comment">     * min(na, nb) elements.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (na &lt;= nb)</span><br><span class="line">        <span class="keyword">return</span> merge_lo(ms, ssa, na, ssb, nb);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> merge_hi(ms, ssa, na, ssb, nb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>merge_at</code>函数实现了一个很重要的逻辑，就是把两个相邻的run之间相对排序结果已经排好序的部分剔除掉，把没有排好序的部分放到<code>merge_lo</code>或者<code>merge_hi</code>里进行merge，这又是一个针对大体有序的数组的优化。把底层设施都写好以后，这个函数看起来十分畅快。先通过gallop确定已经排好序的数组的边界，然后依据数组大小<code>merge_lo</code>或者<code>merge_hi</code>即可。</p>
<h2 id="Collapse-多米诺骨牌"><a href="#Collapse-多米诺骨牌" class="headerlink" title="Collapse-多米诺骨牌"></a>Collapse-多米诺骨牌</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">/* Examine the stack of runs waiting to be merged, merging adjacent runs</span><br><span class="line"> * until the stack invariants are re-established:</span><br><span class="line"> *</span><br><span class="line"> * 1. len[-3] &gt; len[-2] + len[-1]</span><br><span class="line"> * 2. len[-2] &gt; len[-1]</span><br><span class="line"> *</span><br><span class="line"> * See listsort.txt for more info.</span><br><span class="line"> *</span><br><span class="line"> * Returns 0 on success, -1 on error.</span><br><span class="line"> */</span><br><span class="line">static int</span><br><span class="line">merge_collapse(MergeState *ms)</span><br><span class="line">&#123;</span><br><span class="line">    struct s_slice *p = ms-&gt;pending;</span><br><span class="line"></span><br><span class="line">    assert(ms);</span><br><span class="line">    while (ms-&gt;n &gt; 1) &#123;</span><br><span class="line">        Py_ssize_t n = ms-&gt;n - 2;</span><br><span class="line">        if ((n &gt; 0 &amp;&amp; p[n-1].len &lt;= p[n].len + p[n+1].len) ||</span><br><span class="line">            (n &gt; 1 &amp;&amp; p[n-2].len &lt;= p[n-1].len + p[n].len)) &#123;</span><br><span class="line">            if (p[n-1].len &lt; p[n+1].len)</span><br><span class="line">                --n;</span><br><span class="line">            if (merge_at(ms, n) &lt; 0)</span><br><span class="line">                return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (p[n].len &lt;= p[n+1].len) &#123;</span><br><span class="line">            if (merge_at(ms, n) &lt; 0)</span><br><span class="line">                return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* Regardless of invariants, merge all runs on the stack until only one</span><br><span class="line"> * remains.  This is used at the end of the mergesort.</span><br><span class="line"> *</span><br><span class="line"> * Returns 0 on success, -1 on error.</span><br><span class="line"> */</span><br><span class="line">static int</span><br><span class="line">merge_force_collapse(MergeState *ms)</span><br><span class="line">&#123;</span><br><span class="line">    struct s_slice *p = ms-&gt;pending;</span><br><span class="line"></span><br><span class="line">    assert(ms);</span><br><span class="line">    while (ms-&gt;n &gt; 1) &#123;</span><br><span class="line">        Py_ssize_t n = ms-&gt;n - 2;</span><br><span class="line">        if (n &gt; 0 &amp;&amp; p[n-1].len &lt; p[n+1].len)</span><br><span class="line">            --n;</span><br><span class="line">        if (merge_at(ms, n) &lt; 0)</span><br><span class="line">            return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这代码也看得爽啊，原来费劲心机写了那么多函数，现在通通拿来把栈中的run给collapse掉完成排序。注意<code>merge_collapse</code>原来是有bug的，不能只比较栈顶前三个元素是否满足collapse条件，还需要检查第四个。见<a href="https://github.com/python/cpython/commit/b808d590a24066bc03d21b55ed5e890a012477a8" target="_blank" rel="noopener">这个commit</a>。</p>
<h2 id="落幕"><a href="#落幕" class="headerlink" title="落幕"></a>落幕</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/* Compute a good value for the minimum run length; natural runs shorter</span><br><span class="line"> * than this are boosted artificially via binary insertion.</span><br><span class="line"> *</span><br><span class="line"> * If n &lt; 64, return n (it&apos;s too small to bother with fancy stuff).</span><br><span class="line"> * Else if n is an exact power of 2, return 32.</span><br><span class="line"> * Else return an int k, 32 &lt;= k &lt;= 64, such that n/k is close to, but</span><br><span class="line"> * strictly less than, an exact power of 2.</span><br><span class="line"> *</span><br><span class="line"> * See listsort.txt for more info.</span><br><span class="line"> */</span><br><span class="line">static Py_ssize_t</span><br><span class="line">merge_compute_minrun(Py_ssize_t n)</span><br><span class="line">&#123;</span><br><span class="line">    Py_ssize_t r = 0;           /* becomes 1 if any 1 bits are shifted off */</span><br><span class="line"></span><br><span class="line">    assert(n &gt;= 0);</span><br><span class="line">    while (n &gt;= 64) &#123;</span><br><span class="line">        r |= n &amp; 1;</span><br><span class="line">        n &gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return n + r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">reverse_sortslice(sortslice *s, Py_ssize_t n)</span><br><span class="line">&#123;</span><br><span class="line">    reverse_slice(s-&gt;keys, &amp;s-&gt;keys[n]);</span><br><span class="line">    if (s-&gt;values != NULL)</span><br><span class="line">        reverse_slice(s-&gt;values, &amp;s-&gt;values[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一些简单的工具函数，关于<code>minrun</code>的注释非常清晰。接下来的代码包含了许多比较函数，不是本文重点，我们直接进入sort函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">/* An adaptive, stable, natural mergesort.  See listsort.txt.</span><br><span class="line"> * Returns Py_None on success, NULL on error.  Even in case of error, the</span><br><span class="line"> * list will be some permutation of its input state (nothing is lost or</span><br><span class="line"> * duplicated).</span><br><span class="line"> */</span><br><span class="line">/*[clinic input]</span><br><span class="line">list.sort</span><br><span class="line"></span><br><span class="line">    *</span><br><span class="line">    key as keyfunc: object = None</span><br><span class="line">    reverse: bool(accept=&#123;int&#125;) = False</span><br><span class="line"></span><br><span class="line">Stable sort *IN PLACE*.</span><br><span class="line">[clinic start generated code]*/</span><br><span class="line"></span><br><span class="line">static PyObject *</span><br><span class="line">list_sort_impl(PyListObject *self, PyObject *keyfunc, int reverse)</span><br><span class="line">/*[clinic end generated code: output=57b9f9c5e23fbe42 input=b0fcf743982c5b90]*/</span><br><span class="line">&#123;</span><br><span class="line">    MergeState ms;</span><br><span class="line">    Py_ssize_t nremaining;</span><br><span class="line">    Py_ssize_t minrun;</span><br><span class="line">    sortslice lo;</span><br><span class="line">    Py_ssize_t saved_ob_size, saved_allocated;</span><br><span class="line">    PyObject **saved_ob_item;</span><br><span class="line">    PyObject **final_ob_item;</span><br><span class="line">    PyObject *result = NULL;            /* guilty until proved innocent */</span><br><span class="line">    Py_ssize_t i;</span><br><span class="line">    PyObject **keys;</span><br><span class="line"></span><br><span class="line">    assert(self != NULL);</span><br><span class="line">    assert(PyList_Check(self));</span><br><span class="line">    if (keyfunc == Py_None)</span><br><span class="line">        keyfunc = NULL;</span><br><span class="line"></span><br><span class="line">    /* The list is temporarily made empty, so that mutations performed</span><br><span class="line">     * by comparison functions can&apos;t affect the slice of memory we&apos;re</span><br><span class="line">     * sorting (allowing mutations during sorting is a core-dump</span><br><span class="line">     * factory, since ob_item may change).</span><br><span class="line">     */</span><br><span class="line">    saved_ob_size = Py_SIZE(self);</span><br><span class="line">    saved_ob_item = self-&gt;ob_item;</span><br><span class="line">    saved_allocated = self-&gt;allocated;</span><br><span class="line">    Py_SIZE(self) = 0;</span><br><span class="line">    self-&gt;ob_item = NULL;</span><br><span class="line">    self-&gt;allocated = -1; /* any operation will reset it to &gt;= 0 */</span><br><span class="line"></span><br><span class="line">    if (keyfunc == NULL) &#123;</span><br><span class="line">        keys = NULL;</span><br><span class="line">        lo.keys = saved_ob_item;</span><br><span class="line">        lo.values = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        if (saved_ob_size &lt; MERGESTATE_TEMP_SIZE/2)</span><br><span class="line">            /* Leverage stack space we allocated but won&apos;t otherwise use */</span><br><span class="line">            keys = &amp;ms.temparray[saved_ob_size+1];</span><br><span class="line">        else &#123;</span><br><span class="line">            keys = PyMem_MALLOC(sizeof(PyObject *) * saved_ob_size);</span><br><span class="line">            if (keys == NULL) &#123;</span><br><span class="line">                PyErr_NoMemory();</span><br><span class="line">                goto keyfunc_fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; saved_ob_size ; i++) &#123;</span><br><span class="line">            keys[i] = PyObject_CallFunctionObjArgs(keyfunc, saved_ob_item[i],</span><br><span class="line">                                                   NULL);</span><br><span class="line">            if (keys[i] == NULL) &#123;</span><br><span class="line">                for (i=i-1 ; i&gt;=0 ; i--)</span><br><span class="line">                    Py_DECREF(keys[i]);</span><br><span class="line">                if (saved_ob_size &gt;= MERGESTATE_TEMP_SIZE/2)</span><br><span class="line">                    PyMem_FREE(keys);</span><br><span class="line">                goto keyfunc_fail;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lo.keys = keys;</span><br><span class="line">        lo.values = saved_ob_item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* The pre-sort check: here&apos;s where we decide which compare function to use.</span><br><span class="line">     * How much optimization is safe? We test for homogeneity with respect to</span><br><span class="line">     * several properties that are expensive to check at compare-time, and</span><br><span class="line">     * set ms appropriately. */</span><br><span class="line">    if (saved_ob_size &gt; 1) &#123;</span><br><span class="line">        @@@@@@  WEITANGLI: OMMITED  @@@@@@</span><br><span class="line">    &#125;</span><br><span class="line">    /* End of pre-sort check: ms is now set properly! */</span><br><span class="line"></span><br><span class="line">    merge_init(&amp;ms, saved_ob_size, keys != NULL);</span><br><span class="line"></span><br><span class="line">    nremaining = saved_ob_size;</span><br><span class="line">    if (nremaining &lt; 2)</span><br><span class="line">        goto succeed;</span><br><span class="line"></span><br><span class="line">    /* Reverse sort stability achieved by initially reversing the list,</span><br><span class="line">    applying a stable forward sort, then reversing the final result. */</span><br><span class="line">    if (reverse) &#123;</span><br><span class="line">        if (keys != NULL)</span><br><span class="line">            reverse_slice(&amp;keys[0], &amp;keys[saved_ob_size]);</span><br><span class="line">        reverse_slice(&amp;saved_ob_item[0], &amp;saved_ob_item[saved_ob_size]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* March over the array once, left to right, finding natural runs,</span><br><span class="line">     * and extending short natural runs to minrun elements.</span><br><span class="line">     */</span><br><span class="line">    minrun = merge_compute_minrun(nremaining);</span><br><span class="line">    do &#123;</span><br><span class="line">        int descending;</span><br><span class="line">        Py_ssize_t n;</span><br><span class="line"></span><br><span class="line">        /* Identify next run. */</span><br><span class="line">        n = count_run(&amp;ms, lo.keys, lo.keys + nremaining, &amp;descending);</span><br><span class="line">        if (n &lt; 0)</span><br><span class="line">            goto fail;</span><br><span class="line">        if (descending)</span><br><span class="line">            reverse_sortslice(&amp;lo, n);</span><br><span class="line">        /* If short, extend to min(minrun, nremaining). */</span><br><span class="line">        if (n &lt; minrun) &#123;</span><br><span class="line">            const Py_ssize_t force = nremaining &lt;= minrun ?</span><br><span class="line">                              nremaining : minrun;</span><br><span class="line">            if (binarysort(&amp;ms, lo, lo.keys + force, lo.keys + n) &lt; 0)</span><br><span class="line">                goto fail;</span><br><span class="line">            n = force;</span><br><span class="line">        &#125;</span><br><span class="line">        /* Push run onto pending-runs stack, and maybe merge. */</span><br><span class="line">        assert(ms.n &lt; MAX_MERGE_PENDING);</span><br><span class="line">        ms.pending[ms.n].base = lo;</span><br><span class="line">        ms.pending[ms.n].len = n;</span><br><span class="line">        ++ms.n;</span><br><span class="line">        if (merge_collapse(&amp;ms) &lt; 0)</span><br><span class="line">            goto fail;</span><br><span class="line">        /* Advance to find next run. */</span><br><span class="line">        sortslice_advance(&amp;lo, n);</span><br><span class="line">        nremaining -= n;</span><br><span class="line">    &#125; while (nremaining);</span><br><span class="line"></span><br><span class="line">    if (merge_force_collapse(&amp;ms) &lt; 0)</span><br><span class="line">        goto fail;</span><br><span class="line">    assert(ms.n == 1);</span><br><span class="line">    assert(keys == NULL</span><br><span class="line">           ? ms.pending[0].base.keys == saved_ob_item</span><br><span class="line">           : ms.pending[0].base.keys == &amp;keys[0]);</span><br><span class="line">    assert(ms.pending[0].len == saved_ob_size);</span><br><span class="line">    lo = ms.pending[0].base;</span><br><span class="line"></span><br><span class="line">succeed:</span><br><span class="line">    result = Py_None;</span><br><span class="line">fail:</span><br><span class="line">    if (keys != NULL) &#123;</span><br><span class="line">        for (i = 0; i &lt; saved_ob_size; i++)</span><br><span class="line">            Py_DECREF(keys[i]);</span><br><span class="line">        if (saved_ob_size &gt;= MERGESTATE_TEMP_SIZE/2)</span><br><span class="line">            PyMem_FREE(keys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (self-&gt;allocated != -1 &amp;&amp; result != NULL) &#123;</span><br><span class="line">        /* The user mucked with the list during the sort,</span><br><span class="line">         * and we don&apos;t already have another error to report.</span><br><span class="line">         */</span><br><span class="line">        PyErr_SetString(PyExc_ValueError, &quot;list modified during sort&quot;);</span><br><span class="line">        result = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (reverse &amp;&amp; saved_ob_size &gt; 1)</span><br><span class="line">        reverse_slice(saved_ob_item, saved_ob_item + saved_ob_size);</span><br><span class="line"></span><br><span class="line">    merge_freemem(&amp;ms);</span><br><span class="line"></span><br><span class="line">keyfunc_fail:</span><br><span class="line">    final_ob_item = self-&gt;ob_item;</span><br><span class="line">    i = Py_SIZE(self);</span><br><span class="line">    Py_SIZE(self) = saved_ob_size;</span><br><span class="line">    self-&gt;ob_item = saved_ob_item;</span><br><span class="line">    self-&gt;allocated = saved_allocated;</span><br><span class="line">    if (final_ob_item != NULL) &#123;</span><br><span class="line">        /* we cannot use _list_clear() for this because it does not</span><br><span class="line">           guarantee that the list is really empty when it returns */</span><br><span class="line">        while (--i &gt;= 0) &#123;</span><br><span class="line">            Py_XDECREF(final_ob_item[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        PyMem_FREE(final_ob_item);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_XINCREF(result);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数看了也是让人痛心疾首，怎么sort的overhead会这么大。这个函数首先把原先的list置为空来防止在排序中有人改变item的值，然后检查是否调用者指定了<code>key_func</code>即<code>key</code>，如果有则要按之前介绍的那样先把<code>key</code>计算出来，把list里原来存的东西当做<code>value</code>，这里因为相当于凭空多了一个数组所以要进行内存的分配。之后进行的比较函数的选择我们略去。再然后是对<code>reverse</code>这个参数的处理，即实现从大到小排序。粗看起来好像把结果逆序就行了，其实不然，因为我们要的是一个稳定的算法。所以这里要先把未排序数组逆序，然后在排序完成后再进行逆序才可以。<br>之后才正式进入排序，熟悉timsort的话这一段就很好懂，无非就是一个run一个run的进栈，然后不断collapse就好了。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Timsort其实也算不上多么复杂，在mergesort基础上针对有序数组做了一些优化，然而tim毕竟是第一个把鸡蛋立起来的人。其优化主要基础是依据有序程度划分mergesort中各个子merge，把有序的放在一个run里。这样做可能带来一些问题，比如怎样快速选取下一对run进行merge来保证每次merge的两组run长度大体相似（如果相差悬殊则效率很低退化至插入排序），但tim通过精巧地设定初始run的最小长度和一个栈解决了。Gallop的优化对于一般的mergesort理论上也是适用的，但是mergesort可能通过粗暴的划分方式（中点）把数据原本的有序性破坏掉了，因此效果可能不好。<br>此外，将gallop作为二分查找的变种很值得借鉴。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    

    

    </div>

    
  </div>
</article>


    </main>

    <footer class="site-footer">
  <p class="site-info">
    Proudly powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and
    Theme by <a href="https://github.com/CodeDaraW/Hacker" target="_blank">Hacker</a>
    </br>
    
    &copy; 2018 Weitang Li
    
  </p>
</footer>
    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-112074287-1', 'auto');
    ga('send', 'pageview');

</script>

  </div>
</div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>